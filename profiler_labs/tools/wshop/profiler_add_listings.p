/** This is free and unencumbered software released into the public domain.
    Anyone is free to copy, modify, publish, use, compile, sell, or
    distribute this software, either in source code form or as a compiled
    binary, for any purpose, commercial or non-commercial, and by any
    means.  **/
/*------------------------------------------------------------------------
    File        : profilter_add_listings.p
    Purpose     : Inserts DEBUG LISTING files from a known location into profiler output  
    Created     : 2017-03-20
    Notes       : * This assumes the files are in a flat directory structure; the module name's directory and type 
                    delimiters (/,\ (slash, backslash) and . (dot) ) are replaced with _ (underscore)
                  * This naming scheme is different to that generated by the PROFILE itself 
  ----------------------------------------------------------------------*/
block-level on error undo, throw.

using OpenEdge.Core.StringConstant.

/* ********************  Definitions  ******************** */
{profiledata.i}

define variable inputFile as character no-undo.
define variable outputFile as character no-undo.
define variable listingDir as character no-undo.
define variable sessionId as character no-undo.
define variable fileName as character no-undo.
define variable fileExt as character no-undo.
define variable delim as character no-undo.
define variable startPos as integer no-undo.
define variable endPos as integer no-undo.
define variable dotPos as integer no-undo.
define variable loop as integer no-undo.
define variable maxLoop as integer no-undo.

/* ***************************  Main Block  *************************** */
// you can change the source for these values 
assign listingDir   = dynamic-function('getParameter':u in source-procedure, 'listingDir':u)
       inputFile    = dynamic-function('getParameter':u in source-procedure, 'inputFile':u)
       outputFile   = dynamic-function('getParameter':u in source-procedure, 'outputFile':u)
       .

// parses the profilter output file and fills up a bunch of temp-tables
run read_profiler_data.p (inputFile, output sessionId, output dataset profileData).

for each moduleData where
         moduleData.sessionId eq sessionId and
         moduleData.crcValue  gt 0:
    assign moduleData.moduleName = replace(moduleData.moduleName, StringConstant:BACKSLASH, '/':u).
    
    // no path elements are classes or root-level procedures
    if index(moduleData.moduleName, '/':u) eq 0 then
    do:
        // try classes first
        assign file-info:file-name = listingDir + '/':u + replace(moduleData.moduleName, '.':u, '_':u) + '.cls':u.
        
        // if not, the it's a proc 
        if file-info:full-pathname eq ? then
            assign file-info:file-name = listingDir + '/':u + moduleData.moduleName.
        if file-info:full-pathname eq ? then
        do:
            assign dotPos   = r-index(moduleData.moduleName, '.':u)
                   fileName = substring(moduleData.moduleName, 1, dotPos)
                   .
            // assuming this is a .R, look for a file wiht a .P or a .W extension
            if file-info:full-pathname eq ? then
                assign file-info:file-name = listingDir + '/':u + fileName + 'p':u.
            if file-info:full-pathname eq ? then
                assign file-info:file-name = listingDir + '/':u + fileName + 'w':u.
        end.
    end.
    else
    //look for non-class-based programs. Classes cannot have (back)slashes in thier names
    do:
        // first test for a relative dir in the module name
        assign dotPos   = r-index(moduleData.moduleName, '.':u)
               // includes a trailing .
               fileName = replace(substring(moduleData.moduleName, 1, dotPos), '/':u, '_':u)
               fileExt  = substring(moduleData.moduleName, dotPos + 1)
               
               file-info:file-name = listingDir + '/':u + fileName + fileExt
               .
        if file-info:full-pathname eq ? then
        do:
            // assuming this is a .R, look for a file with a .P or a .W extension
            if file-info:full-pathname eq ? then
                assign file-info:file-name = listingDir + '/':u + fileName + 'p':u.
            if file-info:full-pathname eq ? then
                assign file-info:file-name = listingDir + '/':u + fileName + 'w':u.
        end.
        
        // full path for a moduleName
        if file-info:full-pathname eq ? then
        do:
            // if this is a full path we need to look for relative stuff in the listings
            assign maxLoop  = num-entries(moduleData.moduleName, '/':u)
                   fileName = '':u
                   delim    = '':u.
            do loop = maxLoop to 1 by -1:
                assign fileName = entry(loop, moduleData.moduleName, '/':u)
                                + delim
                                + fileName 
                       dotPos   = r-index(fileName, '.':u)
                       delim    = '_':u
                       
                       file-info:file-name = listingDir + '/':u + fileName
                       .
                if file-info:full-pathname eq ? then
                do:
                    // assuming this is a .R, look for a file with a .P or a .W extension
                    if file-info:full-pathname eq ? then
                        assign file-info:file-name = listingDir + '/':u + substring(fileName, 1, dotPos) + 'p'.
                    if file-info:full-pathname eq ? then
                        file-info:file-name = listingDir + '/':u + substring(fileName, 1, dotPos) + 'w'.
                end.
                if file-info:full-pathname ne ? then
                    leave.
            end.
        end.
    end.
    
    assign moduleData.debugListingFile = replace(file-info:full-pathname, StringConstant:BACKSLASH, '/':u).
end.

// write the changed values out for consumption by a tool
run write_profiler_data.p (outputFile, sessionId, dataset profileData by-reference).

return '0':u.

catch e as Progress.Lang.Error :
    message e:GetMessage(1)
    view-as alert-box.
    return string(e:GetMessageNum(1)).
end catch.
/* EOF */